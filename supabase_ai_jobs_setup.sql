-- ===================================================================
-- Table for Managing Asynchronous AI Jobs
-- ===================================================================

-- Ensure pgmq extension is available
CREATE EXTENSION IF NOT EXISTS pgmq;

-- SPLIT


-- Create a dedicated queue for AI tasks
-- Note: 'pgmq.create' might throw if queue exists. Wrapping in DO block or ignoring error is safer, 
-- but for standard migrations, we just run it. 
-- In Supabase, creating an extension requires superuser, usually enabled in dashboard.

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pgmq.meta WHERE queue_name = 'ai_job_queue') THEN
        PERFORM pgmq.create('ai_job_queue');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Queue creation skipped or failed: %', SQLERRM;
END $$;

-- SPLIT



-- Create a table to track job metadata and results for history and debugging
create table if not exists public.ai_job_results (
  id bigint generated by default as identity primary key,
  msg_id bigint unique, -- Corresponds to the pgmq message id (nullable if not yet capable of linking)
  job_type text not null, -- e.g., 'research_strain', 'generate_image'
  payload jsonb not null, -- The initial request data
  status text not null check (status in ('queued', 'processing', 'completed', 'failed')),
  result jsonb, -- The final output from the AI
  error_message text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Enable RLS
alter table public.ai_job_results enable row level security;

-- Only the service role should manage this table
-- We drop strictly before creating to ensure idempotency during iterating
drop policy if exists "Service role full access to ai_job_results." on public.ai_job_results;

create policy "Service role full access to ai_job_results."
on public.ai_job_results
for all
to service_role
using (true)
with check (true);

-- Indexes for fast lookups
create index if not exists ai_job_results_msg_id_idx on public.ai_job_results (msg_id);
create index if not exists ai_job_results_status_idx on public.ai_job_results (status);

-- ===================================================================
-- RPC Wrapper for PGMQ Send (Required for Supabase JS Client)
-- ===================================================================
CREATE OR REPLACE FUNCTION public.pgmq_send(queue_name text, message jsonb)
RETURNS bigint
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  msg_id bigint;
BEGIN
  -- pgmq.send returns the msg_id
  SELECT * INTO msg_id FROM pgmq.send(queue_name, message);
  RETURN msg_id;
END;
$$;

-- ===================================================================
-- RPC Wrapper for PGMQ Read (Pop)
-- ===================================================================
-- Reads 1 message with 30s visibility timeout
DROP FUNCTION IF EXISTS public.pop_ai_job(text) CASCADE;
DROP FUNCTION IF EXISTS public.pop_ai_job() CASCADE;
CREATE OR REPLACE FUNCTION public.pop_ai_job(queue_name text default 'ai_job_queue')
RETURNS TABLE (
  msg_id bigint,
  read_ct integer,
  enqueued_at timestamptz,
  vt timestamptz,
  message jsonb,
  headers jsonb
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY SELECT * FROM pgmq.read(queue_name, 30, 1);
END;
$$;

-- ===================================================================
-- RPC Wrapper for PGMQ Archive/Delete
-- ===================================================================
CREATE OR REPLACE FUNCTION public.archive_ai_job(p_msg_id bigint, queue_name text default 'ai_job_queue')
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  archived_id bigint;
BEGIN
  -- pgmq.archive returns the archived msg_id setof bigint usually, or boolean?
  -- We assume pgmq.archive returns the id or row.
  -- Alternatively, pgmq.delete
  
  -- Using pgmq.archive which moves to archive table
  SELECT * INTO archived_id FROM pgmq.archive(queue_name, p_msg_id);
  RETURN found;
END;
$$;
